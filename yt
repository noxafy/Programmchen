#!/bin/bash

youtube="https://www.youtube.com"
site=""
query=""
CURL=(curl -sSi -H "Accept-Language: de,en-US;q=0.7,en;q=0.3")
DEBUG=
PRINTALL=
OPEN=
STORAGE_DIR="$HOME/.yt"
STORAGE_FILE=
declare -a LINKS
declare -a DESCRIPTIONS
OUTPUTS=
usage="Usage: \e[1m$(basename $0)\e[0m -h | [-a] [-o] [-d] [ \e[4msite\e[0m | -u \e[4muser\e[0m | -c \e[4mchannel\e[0m ] [\e[4mseries\e[0m] [\e[4mquery\e[0m \e[4m...\e[0m]"
help="Some commandline interaction with YouTube.
$usage
	\e[1m-h\e[0m		Displays this message and exits.
	\e[1m-a\e[0m		Print all results from the first page.
	\e[1m-o\e[0m		Just opens the generated link with \e[1mf\[0m.
	\e[1m-d\e[0m		Print some debug logs.
	\e[4msite\e[0m		Videos site (from user or channel) to grep videos from.
	\e[1m-u\e[0m \e[4muser\e[0m		Give a \e[4muser\e[0m name to grep videos from.
	\e[1m-c\e[0m \e[4mname\e[0m		Give a channel's \e[4mname\e[0m to grep videos from.
	\e[1m-i\e[0m \e[4mID\e[0m		Give a channel's \e[4mID\e[0m ID to grep videos from.
	\e[4mseries\e[0m		Filters for special series containing \e[4mseries\e[0m (case insensitive).
	\e[4mquery\e[0m		Search a specified query on YouTube.
"

die() {
  mes=$1
  shift
  [[ -n "$mes" ]] && printf "$mes\n" "$*"
  exit 1
}

while [[ -n $1 ]]; do
  case "$1" in
  -h)
    printf "$help"
    exit 0
    ;;
  -a)
    PRINTALL=true
    ;;
  -d)
    DEBUG=true
    ;;
  -u)
    shift
    [[ -z "$1" ]] && die "Please give a user name with option -u. See -h for more help."
    site="${youtube}/user/${1}/videos"
    STORAGE_FILE="$STORAGE_DIR/$1"
    ;;
  -c)
    shift
    [[ -z "$1" ]] && die "Please give a channel's name  with option -c. See -h for more help."
    site="${youtube}/c/${1}/videos"
    STORAGE_FILE="$STORAGE_DIR/$1"
    ;;
  -i)
    shift
    [[ -z "$1" ]] && die "Please give a channel ID with option -i. See -h for more help."
    site="${youtube}/channel/${1}/videos"
    STORAGE_FILE="$STORAGE_DIR/$1"
    ;;
  -o)
    OPEN=true
    ;;
  -*)
    die "Wrong argument: %s\n$usage -- See -h for more help." "$1"
    ;;
  *)
    [[ -z "$site" ]] && {
      site=$1
      shift
    }
    query="$*"
    break;
    ;;
  esac
  shift
done

function parseResults0() {
  json_file="${STORAGE_FILE}.json"
  printf "%s" "$1" > $json_file
  if [[ -n $DEBUG ]]; then
    echo "Json file saved in ${json_file}" >&2
	fi
  node -e "const filepath = process.argv[1];
      const fs = require('fs');
      const json = JSON.parse(fs.readFileSync(filepath));
      let content = json.contents.twoColumnBrowseResultsRenderer.tabs.filter(el => el.tabRenderer?.content)[0].tabRenderer.content
      let gridRenderer = content.sectionListRenderer.contents[0].itemSectionRenderer.contents[0].gridRenderer

      for (let item of gridRenderer.items) {
        let v = item.gridVideoRenderer

        // get data
        let title = v.title.simpleText  // fallback: v.title.accessibility.accessibilityData.label
        // filter query
        if ('$2' && title.toLowerCase().indexOf('$2'.toLowerCase()) === -1) continue;

        let description
        // Regular video
        if (v.viewCountText.simpleText) {
          let duration = v.thumbnailOverlays[0].thumbnailOverlayTimeStatusRenderer.text.accessibility.accessibilityData.label
          let views = v.viewCountText.simpleText
          let time = v.publishedTimeText.simpleText

          description = title + ' \033[2m' + duration + '\033[0m \033[37m' + time + ' \033[2m' + views + '\033[0m'
        }
        // Livestream
        else if (v.viewCountText.runs) {
          let views = v.viewCountText.runs[0].text
          description = '\033[1mLive:\033[0m ' + title + ' \033[37m' + views + '\033[0m'
        } else {
          console.error('Unknown video type!')
        }

        // create link
        let link = '$youtube' + v.navigationEndpoint.commandMetadata.webCommandMetadata.url

        // print out, remove newlines
        console.log(description.replace(/\r?\n|\r/gm, ''))
        console.log(link)
      }" "$json_file" | perl -MHTML::Entities -pe 'decode_entities($_);'
  [[ -n $DEBUG ]] || rm $json_file
}

function parseResults1() {
  echo "Last time used: $(date +%s)" > ${STORAGE_DIR}/parser_v1
  local json=$(printf "%s" "$1" | pup --charset utf8 '.yt-lockup-content json{}')
  node -e "
    const json = JSON.parse(process.argv[1]);
    for (let el of json) {
      // variable for final string
      let description

      // get title node
      let title;
      for (child of el.children) {
        if (child.class && child.class.includes('yt-lockup-title')) { // normally node [0]
          title = child.children
        }
      }

      if (!title) {
        console.error('Error! This video has no title node (yt-lockup-title):')
        console.error(el)
      }

      // filter by query string
      if ('$2' && title[0].text.toLowerCase().indexOf('$2'.toLowerCase()) === -1) continue;

      // create link
      let link = '$youtube' + title[0].href

      // get meta data node
      let info;
      for (child of el.children) {
        if (child.class && child.class.includes('yt-lockup-meta')) { // normally node [1]
          info = child.children[0].children
        }
      }

      if (!info) {
        console.error('Error! This video has no info node (yt-lockup-meta):')
        console.error(el)
      }

      // Regular video
      if (title[1] && title[1].text
        && info[1] && info[1].text && info[0].text) {
        description = title[0].text + ' \033[2m' + title[1].text + '\033[0m \033[37m' + info[1].text + ' \033[2m' + info[0].text + '\033[0m'
      }
      // Livestream
      else if (el.children[3]
        && el.children[3].children[0].children[0].children[0].text
        && el.children[2].children[0].children[0].text) {
        const live_txt = el.children[3].children[0].children[0].children[0].text
        const viewer_cnt = el.children[2].children[0].children[0].text
        description = '\033[1m' + live_txt + ':\033[0m ' + title[0].text + ' \033[37m' + viewer_cnt + '\033[0m'
      }
      else {
        description = 'Unknown video type!'
      }

      // print out, remove newlines
      console.log(description.replace(/\r?\n|\r/gm, ''))
      console.log(link)
    }" "$json" | perl -MHTML::Entities -pe 'decode_entities($_);'
}

function parseResults() {
  # find place of content in html
	local v1=$(printf "%s" "$1" | grep 'window\["ytInitialData"\]' | sed 's/    window\["ytInitialData"\] = //' | sed 's/;$//')
  if [[ -n "$v1" ]]; then
    local tmp_results=$(parseResults0 "$v1" "$2")
  else
	  local v2=$(printf "%s" "$1" | pup --charset utf8 '.yt-lockup-content')
    [[ -z "$v2" ]] && die "Couldn't parse html"
    local tmp_results=$(parseResults1 "$v2" "$2")
  fi
  local tmp_descriptions=$(printf "%s" "$tmp_results" | sed -n 'p;n')
  IFS=$'\n' DESCRIPTIONS=(${tmp_descriptions})
  local tmp_links=$(printf "%s" "$tmp_results" | sed -n '1d;p;n')
  IFS=$'\n' LINKS=(${tmp_links})

  if [[ -n $DEBUG ]]; then
    if [[ -n "$query" ]]; then
      local all_results=$(parseResults0 "$1")
      printf "All results:\n%s\n" "$all_results"
      printf "Filtered results:\n%s\n" "$tmp_results"
    else
      printf "Results:\n%s\n" "$tmp_results"
    fi
  fi

  if [[ ${#DESCRIPTIONS[@]} -eq 0 ]]; then
    if [[ -n $2 ]]; then
      die "No results found for \"$2\". Try another."
    else
      die "No results found. Probably a script failure."
    fi
  fi
}

# fetch videos from youtube site $1, filtered by optional query $2
function fetchVideos() {
  waitnet -s >&2 || exit 1

  if [[ -n $DEBUG ]]; then
    printf '"%s" ' "${CURL[@]}" >&2
    printf "%s\n" "$1" >&2
  fi

  # curl fetch
  if [[ -n "$PROXY" ]]; then
    #ip=$(curl -sS --socks5-hostname "$PROXY" ifconfig.me)
    #echo "Using proxy ($ip)"
    local src=$("${CURL[@]}" --socks5-hostname "$PROXY" "$1")
  else
    #echo "Using no proxy ($(curl -sS ifconfig.me))"
    local src=$("${CURL[@]}" "$1")
  fi

  if [[ -n $DEBUG ]]; then
    result_name="${STORAGE_FILE}_$(date +%s)"
    echo "Curl result saved in ${result_name}" >&2
    echo "$src" > "${result_name}"
  fi

  http_status=$(echo "$src" | sed -n '1p')
  case "$http_status" in
    *200*)
      ;;
    *404*|*303*)
      if [[ $1 = */user/* ]]; then
        die "Bad username: %s\n" $(printf "%s" "$1" | sed -e 's/.*\/user\///' -e 's/\/videos//')
      else
        die "Channel does not exist: $1"
      fi
      return
      ;;
    *)
      echo "Uncaught HTTP Error: $http_status"
      return
      ;;
  esac

  parseResults "$src" "$2"

  if [[ ${#DESCRIPTIONS[@]} != ${#LINKS[@]} ]]; then
    printf "WTF-Error: %d descriptions, but %d links!\n" ${#DESCRIPTIONS[@]} ${#LINKS[@]}
    printf "DESCRIPTIONS:\n"
    printf '%s\n' "${DESCRIPTIONS[@]}"
    printf "LINKS:\n"
    printf '%s\n' "${LINKS[@]}"
    die
  fi
}

function setupOutputsVariable() {
  OUTPUTS=
  cnt=0
  IFS=$'\n'
  for idx in "${!DESCRIPTIONS[@]}"; do # an array is basically a dictionary with index as key; get keys with ${!arr[@]}
    OUTPUTS+=$(printf "%s: %s \033[2m%s\033[0m" "$((idx+1))" "${DESCRIPTIONS[$idx]}" "${LINKS[$idx]}")$'\n' # increment for zero-based to one-based conversion; why does newline in printf not work?
  done
}

function filterLinks() {
  local content=
  if [[ -e "$STORAGE_FILE" ]]; then
    content=$(< "$STORAGE_FILE")
  fi

  if [[ -z $PRINTALL ]]; then
    # filter DESCRIPTIONS and LINKS to contain only new elements
    for idx in "${!LINKS[@]}"; do
      if [[ "$content" == *"${LINKS[$idx]}"* ]]; then
        unset 'LINKS[$idx]'
        unset 'DESCRIPTIONS[$idx]'
      fi
    done
    # rebuild indicies
    local -a NEW_LINKS
    local -a NEW_DESCRIPTIONS
    for idx in "${!LINKS[@]}"; do
      NEW_LINKS+=("${LINKS[$idx]}")
      NEW_DESCRIPTIONS+=("${DESCRIPTIONS[$idx]}")
    done
    LINKS=("${NEW_LINKS[@]}")
    DESCRIPTIONS=("${NEW_DESCRIPTIONS[@]}")
    unset NEW_LINKS
    unset NEW_DESCRIPTIONS
  fi
}

function askForChoose() {
  if [[ ${#DESCRIPTIONS[@]} -eq 1 ]]; then
    printf "Only one result found. Do you want to open it? (y/n) [y]: "
    read ans
    case $ans in
      ""|j|y|J|Y|Yes)
        if [[ -z $DEBUG ]]; then
          f -i "${LINKS[0]}"
        else
          printf "f -i %s\n" "${LINKS[0]}"
        fi
      ;;
      *)
      ;;
    esac
    exit 0
  else
    printf "Which one do you want to open? (1-%d/q) [1]: " ${#DESCRIPTIONS[@]}
    read ans
    [[ -z "$ans" ]] && ans=1
    if [[ $ans =~ ^[0-9]+$ ]]; then
      if [[ $ans -gt 0 && $ans -le ${#DESCRIPTIONS[@]} ]]; then
        ((ans--)) # decrement to convert from one-based to zero based
        local link=${LINKS[${ans}]}
        if [[ -z $DEBUG ]]; then
          f "$link"
        else
          printf "f %s" "$link"
        fi
        [[ $ans -eq 0 ]] && exit 0
      else
        die "Wrong answer. Integer is zero or too high: $ans."
      fi
    else
      printf "Nothing opened.\n"
      exit 0
    fi
  fi
}

function updateLocalStorage() {
  printf "%s" "$OUTPUTS" > "$STORAGE_FILE"
}

if [[ "$site" = ${youtube}* ]]; then
  if [[ -n $OPEN ]]; then
    if [[ -z $DEBUG ]]; then
      echo "open $site"
      f -i "$site"
    else
      printf "f -i %s\n" "$site"
    fi
    exit 0
  fi
  if [[ "$site" = */videos ]]; then
    fetchVideos "$site" "$query"
    setupOutputsVariable

    if [[ -z $PRINTALL ]]; then
      filterLinks
    fi
    updateLocalStorage
    if [[ -z $PRINTALL ]]; then
      setupOutputsVariable
    fi

    if [[ ${#DESCRIPTIONS[@]} -eq 0 ]]; then
      if [[ -z $PRINTALL ]]; then
        printf "No new videos!\n"
      else
        printf "No videos found!\n"
      fi
      exit 0
    fi

    if [[ ! -t 1 ]]; then # not interactive
      printf "%s" "$OUTPUTS"
      exit 0
    fi

    printf "%s" "$OUTPUTS"
    askForChoose
    while true; do
      askForChoose
    done
  else
    [[ -n "$query" ]] && printf "Warning: query will be ignored: %s\n" "$query" >&2
    if [[ -z $DEBUG ]]; then
      f -i "$site"
    else
      printf "f -i %s\n" "$site"
    fi
  fi
else
  # since $site is just the first given non-option argument, handle it here as query as well
  query="$site $query"
  if [[ -z $DEBUG ]]; then
    f yt "$query"
  else
    printf "f yt %s\n" "$query"
  fi
fi
