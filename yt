#!/bin/bash

youtube="https://www.youtube.com"
site=""
query=""
CURL=(curl -sS -H "Accept-Language: de,en-US;q=0.7,en;q=0.3")
DEBUG=
PRINTALL=
STORAGE_DIR="$HOME/.yt"
STORAGE_FILE=w
declare -a LINKS
declare -a DESCRIPTIONS
OUTPUTS=
usage="Usage: \e[1m$(basename $0)\e[0m -h | [-d] [-a] [ \e[4msite\e[0m | -u \e[4muser\e[0m | -c \e[4mchannel\e[0m ] [\e[4mseries\e[0m] [\e[4mquery\e[0m \e[4m...\e[0m]"
help="Some commandline interaction with YouTube.
$usage
	\e[1m-h\e[0m		Displays this message and exits.
        \e[1m-a\e[0m            Print all results from the first page.
        \e[1m-d\e[0m            Print some debug logs.
	\e[4msite\e[0m		Videos site (from user or channel) to grep videos from.
	\e[1m-u\e[0m \e[4muser\e[0m		Give a \e[4muser\e[0m name to grep videos from.
	\e[1m-c\e[0m \e[4mchannel\e[0m	Give a \e[4mchannel\e[0m to grep videos from.
	\e[4mseries\e[0m		Filters for special series containing \e[4mseries\e[0m (case insensitive).
	\e[4mquery\e[0m		Search a specified query on YouTube.

Dependency to \"node\".
"

die() {
  mes=$1
  shift
  [[ -n "$mes" ]] && printf "$mes\n" "$*"
  exit 1
}

while [[ -n $1 ]]; do
  case "$1" in
  -h)
    printf "$help"
    exit 0
    ;;
  -a)
    PRINTALL=true
    ;;
  -d)
    DEBUG=true
    ;;
  -u)
    shift
    [[ -z "$1" ]] && die "Please give a user name with option -u. See -h for more help."
    site="${youtube}/user/${1}/videos"
    STORAGE_FILE="$STORAGE_DIR/$1"
    ;;
  -c)
    shift
    [[ -z "$1" ]] && die "Please give a channel with option -c. See -h for more help."
    site="${youtube}/channel/${1}/videos"
    STORAGE_FILE="$STORAGE_DIR/$1"
    ;;
  -*)
    die "Wrong argument: %s\n$usage -- See -h for more help." "$1"
    ;;
  *)
    [[ -z "$site" ]] && {
      site=$1
      shift
    }
    query="$*"
    break;
    ;;
  esac
  shift
done

function parseResults0() {
  local json=$(printf "%s" "$1" | pup --charset utf8 '.yt-lockup-content json{}')
  if [[ -n $DEBUG ]]; then
    result_name="result_$(date +%s)"
    echo "Curl result saved in ${result_name}.html and ${result_name}.json" >&2
    echo "$1" > "${result_name}.html"
    echo "$json" > "${result_name}.json"
  fi
  node -e "
    const json = JSON.parse(process.argv[1]);
    for (let el of json) {
      // variable for final string
      let description

      // get title node
      let title;
      for (child of el.children) {
        if (child.class && child.class.includes('yt-lockup-title')) { // normally node [0]
          title = child.children
        }
      }

      if (!title) {
        console.error('Error! This video has no title node (yt-lockup-title):')
        console.error(el)
      }

      // filter by query string
      if ('$2' && title[0].text.toLowerCase().indexOf('$2'.toLowerCase()) === -1) continue;

      // create link
      let link = '$youtube' + title[0].href

      // get meta data node
      let info;
      for (child of el.children) {
        if (child.class && child.class.includes('yt-lockup-meta')) { // normally node [1]
          info = child.children[0].children
        }
      }

      if (!info) {
        console.error('Error! This video has no info node (yt-lockup-meta):')
        console.error(el)
      }

      // Regular video
      if (title[1] && title[1].text
        && info[1] && info[1].text && info[0].text) {
        description = title[0].text + ' \033[2m' + title[1].text + '\033[0m \033[37m' + info[1].text + ' \033[2m' + info[0].text + '\033[0m'
      }
      // Livestream
      else if (el.children[3]
        && el.children[3].children[0].children[0].children[0].text
        && el.children[2].children[0].children[0].text) {
        const live_txt = el.children[3].children[0].children[0].children[0].text
        const viewer_cnt = el.children[2].children[0].children[0].text
        description = '\033[1m' + live_txt + ':\033[0m ' + title[0].text + ' \033[37m' + viewer_cnt + '\033[0m'
      }
      else {
        description = 'Unknown video type!'
      }

      // print out, remove newlines
      console.log(description.replace(/\r?\n|\r/gm, ''))
      console.log(link)
    }" "$json" \
    | perl -MHTML::Entities -pe 'decode_entities($_);'
}

function parseResults() {
  local tmp_results=$(parseResults0 "$1" "$2")
  local tmp_descriptions=$(printf "%s" "$tmp_results" | sed -n 'p;n')
  IFS=$'\n' DESCRIPTIONS=(${tmp_descriptions})
  local tmp_links=$(printf "%s" "$tmp_results" | sed -n '1d;p;n')
  IFS=$'\n' LINKS=(${tmp_links})

  if [[ -n $DEBUG ]]; then
    if [[ -n "$query" ]]; then
      local all_results=$(parseResults0 "$1")
      printf "All results:\n%s\n" "$all_results"
      printf "Filtered results:\n%s\n" "$tmp_results"
    else
      printf "Results:\n%s\n" "$tmp_results"
    fi
  fi

  if [[ ${#DESCRIPTIONS[@]} -eq 0 ]]; then
    if [[ -n $2 ]]; then
      die "No results found for \"$2\". Try another."
    else
      die "No results found. Probably a script failure."
    fi
  fi
}

# fetch videos from youtube site $1, filtered by optional query $2
function fetchVideos() {
  waitnet -s >&2 || exit 1

  # curl fetch
  if [[ -n "$PROXY" ]]; then
    #ip=$(curl -sS --socks5-hostname "$PROXY" ifconfig.me)
    #echo "Using proxy ($ip)"
    local src=$("${CURL[@]}" --socks5-hostname "$PROXY" "$1")
  else
    #echo "Using no proxy ($(curl -sS ifconfig.me))"
    local src=$("${CURL[@]}" "$1")
  fi

  if [[ -n $src ]]; then
    local content=$(printf "%s" "$src" | pup --charset utf8 '.yt-lockup-content')

    # trouble shooting
    if [[ -z "$content" ]]; then
      local channel_empty=$(printf "%s" "$src" | pup '.channel-empty-message')
      [[ -n "$channel_empty" ]] && {
        if [[ $1 = */user/* ]]; then
          die "Bad username: %s\n" $(printf "%s" "$1" | sed -e 's/.*\/user\///' -e 's/\/videos//')
        else
          die "Channel does not exist: $1"
        fi
      }
      local title=$(printf "%s" "$src" | pup --charset utf8 'title text{}')
      die "No content found: $title: $1"
    fi

    parseResults "$content" "$2"

    if [[ ${#DESCRIPTIONS[@]} != ${#LINKS[@]} ]]; then
      printf "WTF-Error: %d descriptions, but %d links!\n" ${#DESCRIPTIONS[@]} ${#LINKS[@]}
      printf "DESCRIPTIONS:\n"
      printf '%s\n' "${DESCRIPTIONS[@]}"
      printf "LINKS:\n"
      printf '%s\n' "${LINKS[@]}"
      die
    fi
  else
    die "Fetching from $1 failed."
  fi
}

function setupOutputsVariable() {
  OUTPUTS=
  cnt=0
  IFS=$'\n'
  for idx in "${!DESCRIPTIONS[@]}"; do # an array is basically a dictionary with index as key; get keys with ${!arr[@]}
    OUTPUTS+=$(printf "%s: %s \033[2m%s\033[0m" "$((idx+1))" "${DESCRIPTIONS[$idx]}" "${LINKS[$idx]}")$'\n' # increment for zero-based to one-based conversion; why does newline in printf not work?
  done
}

function filterLinks() {
  local content=
  if [[ -e "$STORAGE_FILE" ]]; then
    content=$(< "$STORAGE_FILE")
  fi

  if [[ -z $PRINTALL ]]; then
    # filter DESCRIPTIONS and LINKS to contain only new elements
    for idx in "${!LINKS[@]}"; do
      if [[ "$content" == *"${LINKS[$idx]}"* ]]; then
        unset 'LINKS[$idx]'
        unset 'DESCRIPTIONS[$idx]'
      fi
    done
    # rebuild indicies
    local -a NEW_LINKS
    local -a NEW_DESCRIPTIONS
    for idx in "${!LINKS[@]}"; do
      NEW_LINKS+=("${LINKS[$idx]}")
      NEW_DESCRIPTIONS+=("${DESCRIPTIONS[$idx]}")
    done
    LINKS=("${NEW_LINKS[@]}")
    DESCRIPTIONS=("${NEW_DESCRIPTIONS[@]}")
    unset NEW_LINKS
    unset NEW_DESCRIPTIONS
  fi
}

function askForChoose() {
  if [[ ${#DESCRIPTIONS[@]} -eq 1 ]]; then
    printf "Only one result found. Do you want to open it? (y/n) [y]: "
    read ans
    case $ans in
      ""|j|y|J|Y|Yes)
        if [[ -z $DEBUG ]]; then
          f -i "${LINKS[0]}"
        else
          printf "f -i %s\n" "${LINKS[0]}"
        fi
      ;;
      *)
      ;;
    esac
    exit 0
  else
    printf "Which one do you want to open? (1-%d/q) [1]: " ${#DESCRIPTIONS[@]}
    read ans
    [[ -z "$ans" ]] && ans=1
    if [[ $ans =~ ^[0-9]+$ ]]; then
      if [[ $ans -gt 0 && $ans -le ${#DESCRIPTIONS[@]} ]]; then
        ((ans--)) # decrement to convert from one-based to zero based
        local link=${LINKS[${ans}]}
        if [[ -z $DEBUG ]]; then
          f "$link"
        else
          printf "f %s" "$link"
        fi
        [[ $ans -eq 0 ]] && exit 0
      else
        die "Wrong answer. Integer is zero or too high: $ans."
      fi
    else
      printf "Nothing opened.\n"
      exit 0
    fi
  fi
}

function updateLocalStorage() {
  printf "%s" "$OUTPUTS" > "$STORAGE_FILE"
}

if [[ "$site" = ${youtube}* ]]; then
  if [[ "$site" = */videos ]]; then
    fetchVideos "$site" "$query"
    setupOutputsVariable

    if [[ -z $PRINTALL ]]; then
      filterLinks
    fi
    updateLocalStorage
    if [[ -z $PRINTALL ]]; then
      setupOutputsVariable
    fi

    if [[ ${#DESCRIPTIONS[@]} -eq 0 ]]; then
      if [[ -z $PRINTALL ]]; then
        printf "No new videos!\n"
      else
        printf "No videos found!\n"
      fi
      exit 0
    fi

    if [[ ! -t 1 ]]; then # not interactive
      printf "%s" "$OUTPUTS"
      exit 0
    fi

    printf "%s" "$OUTPUTS"
    askForChoose
    while true; do
      askForChoose
    done
  else
    [[ -n "$query" ]] && printf "Warning: query will be ignored: %s\n" "$query" >&2
    if [[ -z $DEBUG ]]; then
      f -i "$site"
    else
      printf "f -i %s\n" "$site"
    fi
  fi
else
  if [[ -z $DEBUG ]]; then
    f yt "$site $query"
  else
    printf "f yt %s %s\n" "$site" "$query"
  fi
fi
