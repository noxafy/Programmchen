#!/bin/bash

usage="Usage: \e[1m$(basename $0)\e[0m -h | [\e[4mmessage\e[0m \e[4mfiles\e[0m \e[4m...\e[0m]"
help="Updates git repository by stashing away current changes, pulling (rebase), and commiting if message and files specified.
$usage
        \e[1m-h\e[0m	Display this message and exit.
	\e[4mmessage\e[0m	Commit message. Obligatory for committing.
        \e[4mfile\e[0m	Files to commit if they have changes.
"

function die() {
  mes=$1
  shift
  [[ -n "$mes" ]] && printf "$mes\n" "$@"
  exit 1
}

case $1 in
  -h)
    printf "$help"
    exit 0
    ;;
  *)
    mes=$1
    if [[ -n "$1" ]]; then
      if [[ -e "$1" ]]; then
        echo "Commit message: $1"
        if [[ -t 0 && -t 1 ]]; then
          printf "Are you sure you want to continue? Press enter: "
          read trash
        fi
      fi
      shift
    fi
    ;;
esac

git rev-parse --show-toplevel &> /dev/null || {
  echo "This is not a git repository."
  exit 1
}

res=$(git stash save)
ec=$?
echo "$res"
[[ $ec -eq 0 ]] || exit $ec

git pull --rebase

if [[ "No local changes to save" != "$res" ]]; then
  git stash pop || exit $?
fi

if [[ -n "$1" ]]; then # if file to commit given
  untracked=$(git ls-files -z --others --exclude-standard | xargs -0 -n 1 printf "%s\n")
  doubled=$(printf "%s\n" "$@" && git diff --name-only && printf "%s" "$untracked") # stash removes from stage
  toCommit=$(printf "%s" "$doubled" | sort | uniq -d)
  if [[ -n "$toCommit" ]]; then
    git add "$@" \
    && git commit -m "$mes" \
    && git push
  fi
fi
