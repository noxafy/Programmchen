#!/bin/bash

#############################
### ls
#############################
alias l=ll
alias la="lsd -a" #="ls -A"
alias ll="lsd -laF" #='ls -liAF'
alias tl="tree -faFhpN --du"
alias td="tree -faFhpNd --du"
alias fd="fd -H"
alias fdd="fd -t d"
alias fdf="fd -t f"
alias fzf="fzf --no-mouse --bind='ctrl-t:toggle-preview' --exit-0 --color=hl:9,hl+:1 --preview=\"if [[ -r {} ]]; then \
  printf '\e[37m'; file {} | tr -d '\n'; printf ' ('; stat -f '%z' {} | tr -d '\n'; printf ' Bytes)'; printf '\e[0m\n'; cat {}; \
elif [[ -r {-1} ]]; then \
  printf '\e[37m'; file {-1} | tr -d '\n'; printf ' ('; stat -f '%z' {-1} | tr -d '\n'; printf ' Bytes)'; printf '\e[0m\n'; cat {-1}; \
else \
  echo 'Invalid file name: ' {}; \
fi\" --preview-window=right:hidden"
alias lsusers="dscl . list /Users | grep -v ^_"

#############################
### git
#############################
alias gd="PAGER=/usr/local/share/git-core/contrib/diff-highlight/diff-highlight git diff" # use with colors in ~/.gitconfig as described in https://www.viget.com/articles/dress-up-your-git-diffs-with-word-level-highlights/
alias gds="gd --staged"
alias gdw="PAGER= git diff --word-diff=color"
alias gdws="gdw --staged"
alias gst="git status"
alias ga="git add"
alias a="git add"
alias glt='git ls-tree -r --name-only "$(git rev-parse --short HEAD)"'
alias glf='git log --graph --abbrev-commit --decorate --format=format:'\''%C(yellow)%h%C(reset) - %C(cyan)%aD (%ar)%C(reset)%C(white)%d%C(reset)%n'\'\''          %s%C(dim) - %aN <%aE>%C(reset)'\'' --all'
alias gup=git_update
alias grh^="git reset HEAD^"
alias grh^^="git reset HEAD^^"
alias grh^2="git reset HEAD^2"

function c() {
  git status > /dev/null || return
  if [[ $(git config --show-origin user.email) != file:.git/config* ]]; then
    echo "Please set up user.name and user.email first!"
    local def_name=$(git config user.name)
    printf "user.name [%s]: " "$def_name"
    local name; read name
    [[ -z $name ]] && name=$def_name
    git config user.name "$name"

    local def_email=$(git config user.email)
    printf "user.email [%s]: " "$def_email"
    local email; read email
    [[ -z $email ]] && email=$def_email
    git config user.email "$email"
  fi

  git commit -m "$*"
}

#############################
### hacky
#############################
alias ec='echo $?'
alias q=exit
alias rg="rg --hidden --glob '!.git/*'"
alias g=grep
alias hist=history
alias h="waitnet -s && howdoi"
alias mvninit="mvn archetype:generate"
alias cal="gcal --starting-day=1 --with-week-number -q DE_BY -G"
alias cal3="gcal --starting-day=1 --with-week-number -q DE_BY --force-highlighting .+ | sed -n '6,\$p'"
alias vwc='pbpaste | wc'
alias wctex="pbpaste | sed 's/^%.*//' | wc -w"
alias ql="qlmanage -p"
alias shutup="osascript -e 'Set volume output volume 0'"

function cltex() {
  local goal=$1
  [[ -z "$goal" && -e "main.tex" ]] && goal="main.tex"
  if [[ ! -e "$goal" || "$goal" != *.tex ]]; then
    echo "Please give a valid tex file." && return 1
  fi

  local -i removed=0
  local -a tokill=(aux bbl bcf blg dvi fdb_latexmk fls idx ilg ind lof log lot out out.ps run.xml toc)
  for postfix in ${tokill[@]}; do
    local file="${goal:0:$((${#goal}-4))}.$postfix"
    [[ -e "$file" ]] && rm -v "$file" && ((removed++))
  done
  echo "$removed files removed"
}

function meta() {
  if hash exiftool &>/dev/null; then
    if [[ -z "$1" ]]; then
      echo "Please give a file to show its metadata."
    else
      exiftool "$1"
    fi
  else
    echo "Please install exiftool before."
  fi
}

function rmmeta() {
  if hash exiftool &>/dev/null; then
    if [[ -z "$1" ]]; then
      echo "Please give a file to remove metadata from."
    else
      exiftool -all= -overwrite_original "$1"
    fi
  else
    echo "Please install exiftool before."
  fi
}

function filecnt() {
  \fd -I0Ht d -d 1 | while IFS= read -r -d '' f; do
    printf "$f: "
    \fd -IH -t f '.*' "$f" | wc -l
  done | awk '{print $NF"\t"$0}' | sed -E 's/:.*$//g' | sort -nr
}

#############################
### internet
#############################
alias airport=/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport
function wlan() {
  networksetup -setairportpower en0 $1 1> /dev/null || echo "on|off"
}
alias won="wlan on"
alias woff="wlan off"

alias wi="wiki -l de"
alias geta="youtube-dl -x --audio-format mp3 --audio-quality 0"
alias yt720="youtube-dl -f 'bestvideo[height<=720]+bestaudio/best[height<=720]'"
alias yt1080="youtube-dl -f 'bestvideo[height<=1080]+bestaudio/best[height<=1080]'"

function uriencode() {
  if hash node &>/dev/null; then
    node -e 'console.log(encodeURIComponent(process.argv[1]))' "$*"
  else
    curl -Gso /dev/null -w %{url_effective} --data-urlencode "$*" "" | cut -c 3-
  fi
}

function uridecode() {
  node -e 'console.log(decodeURIComponent(process.argv[1]))' "$*"
}

function fetch_dwd() { # german weather agency / usage: $0 "state" "city"
# see https://www.dwd.de/DWD/warnungen/warnapp_gemeinden/viewer/gemeinden.js?v=2
  local dwd_site=https://www.dwd.de/DE/wetter/warnungen_gemeinden/warntabellen/
  local dwd_url="${dwd_site}warntab_$1_node.html"

  local res http_status
  res=$(curl -sSi "$dwd_url") || return $?
  http_status=$(echo "$res" | sed -n '1p')
  case "$http_status" in
    *200*)
      ;;
    *404*)
      echo "Probably bad state argument: $1"
      echo "Link not found (404): $dwd_url"
      return
      ;;
    *)
      echo "Error: $http_status"
      return
      ;;
  esac

  local enc_location=$(echo "$2" | recode latin1..utf8)
  local wetterwarnung=$(echo "$res" | sed -n "/<h2 id=\"${enc_location}\"/,/<\/table>/p")
  if [[ -n $wetterwarnung ]]; then
    echo $wetterwarnung | tr '\n' ' ' | grep -oE "<h2 id=\"${enc_location}\".*</table>" | sed 's/<thead>.*<\/thead>//' | pup 'text{}' | xargs -L 1 echo
  else
    echo "Keine amtlichen Wetterwarnungen für ${2}."
  fi
}

function fetch_dwd2() {
  echo "ERROR: NIY"
  # 1. fetch warnings from https://www.dwd.de/DWD/warnungen/warnapp_gemeinden/json/warnings_gemeinde.json
  # 2. remove "warnWetter.loadWarnings(" and ");"
  # 3. find right polygon for desired city (stuck here)
}

function fetchPrecipitation() { # wetter.com / usage: $0 $lat $lng
  local lat=$1 lng=$2
  [[ -z $lat || -z $lng || ! "$lat" =~ ^[0-9]+.[0-9]+$ || ! "$lng" =~ ^[0-9]+.[0-9]+$ ]] && {
    echo "Usage: $0 \e[4mlat\e[0m \e[4mlng\e[0m"
    return 1;
  }

  local ans res
  ans=$(curl -Ss -A 'Firefox/66.0' -H "Accept-Language: en-US" -H "X-Requested-With: XMLHttpRequest" https://www.wetter.com/wetter_aktuell/nowcast_update/ --data-urlencode "lat=$lat" --data-urlencode "lng=$lng") || return $?
  res=$(node -e 'const ans=JSON.parse(process.argv[1]);
    console.log(ans.text)
    function hexToRgb(hex) {
      if (hex.charAt(0) === "#") hex = hex.substring(1);
      if (hex.length === 3) hex = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2)
      let bigint = parseInt(hex, 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      }
    }
    for (let e of ans.events) {
      if (e.precipitation === 0) continue;
      let c = hexToRgb(e.color)
      e.precipitation="\\e[38;2;" + c.r + ";" + c.g + ";" + c.b + "m" + e.precipitation.toFixed(1) + "mm"
      console.log("%s\t%s (%s)\\e[0m", e.time, e.precipitation, e.short)
    }' "$ans" | sed 's/<span class="\[ text--blue-dark \]">/\\e[34;1m/g;s/<\/span>/\\e[0m/g')
  echo "$res"
}

function fetchWind() { # Usage: $0 <path on wetter.com>
  local res parsed
  res=$(curl -sS "https://www.wetter.com$1") || return $?
  #echo "$res" | pup '.icon-wind_arrow attr{title}' | sed -n '9,$p' | nl -v $(date +%H) | awk '{print $1 % 24 ":00\t" $2}'
  parsed=$(echo "$res" | pup '.hwg-col-wind-text json{}')
  node -e 'const ans=JSON.parse(process.argv[1]); for (wind of ans) { console.log(wind.text)}' "$parsed" | nl -v $(date +%H) | awk '{
    res=$1 % 24;
    if (res < 10)
      $1="0"res":00  ";
    else
      $1=res":00  ";
    print $0
  }' | sed -E 's/([[:alpha:]]) /\1    /;s/([[:alpha:]][[:alpha:]])  /\1 /;s/ Böen/  Böen/g'
}

#############################
### applications
#############################
alias bs="brew search"
alias bi="brew info"
alias bh="brew home"
alias play="spotify play"
alias pause="spotify pause"
alias next="spotify next"
alias prev="spotify prev"
alias show="defaults write com.apple.finder AppleShowAllFiles YES && killall Finder"
alias hide="defaults write com.apple.finder AppleShowAllFiles NO && killall Finder"
alias lftp="sudo -s launchctl load -w /System/Library/LaunchDaemons/ftp.plist"
alias uftp='sudo -s launchctl unload -w /System/Library/LaunchDaemons/ftp.plist && sudo kill $(ps -ax | grep ftpd | grep -v grep | grep -o "\d\+" | sed -n 1p) > /dev/null 2>&1'
alias dark="osascript -e 'tell application \"System Events\" to tell appearance preferences to set dark mode to not dark mode'"

#############################
### fi*
#############################
function fif() {
  typeset -f | grep --color=never -E ' \(\) \{?' | sed -E 's/ \(\) \{?$//g' | grep -e "$*"
}

function fia() {
  alias | sed 's/^alias //g' | grep -e "$*"
}

#############################
### files
#############################
function _pick() {
  local file_only=$1
  shift

  local q_dirname
  local query
  local -a fd_args
  if [[ -n "$*" ]]; then
    if [[ -f "$*" && -r "$*" ]]; then
      # existing file given
      echo "$*"
      return;
    elif [[ -d "$*" && -r "$*" ]]; then
      # existing dir given (to search in or give back)
      if $file_only; then
        q_dirname="$*"
      else
        echo "$*"
        return;
      fi
    else
      q_dirname=$(dirname "$*")
      if [[ -d "$q_dirname" && -r "$q_dirname" ]]; then
        # invalid path given, but parent exists
        query=$(basename "$*")
      else
        query="$*"
      fi
    fi
  else
    q_dirname="$PWD"
  fi

  [[ "true" == "$file_only" ]] && fd_args=(-t f)

  local -a depth_indicator
  if [[ -n "$q_dirname" ]]; then # if valid dirname given, cd there
    pushd "$q_dirname" > /dev/null
  fi
  local pwd_name
  if [[ $PWD == $HOME ]]; then
    depth_indicator=(-d 1)
    pwd_name="~"
  elif [[ / == "$PWD" ]]; then
    depth_indicator=(-d 1)
    pwd_name=""
  elif [[ / == $(dirname "$PWD") ]]; then
    pwd_name="$PWD"
  else
    pwd_name=$(basename "$PWD")
  fi

  local picked
  picked=$(/usr/local/bin/fd "${fd_args[@]}" "${depth_indicator[@]}" -H | grep -v '\.git/' | fzf --query="$query" --prompt="$pwd_name/ " --preview-window=right)
  local exit_code=$?

  [[ "${q_dirname:${#q_dirname}-1:1}" != "/" ]] && q_dirname="$q_dirname/"
  case $exit_code in
    0) # found
      echo "$q_dirname$picked"
      ;;
    1) # not found
      echo "$q_dirname$query"
      ;;
    *)
      return $exit_code
      ;;
  esac
}

function _pick_and_execute() {
  local file_only=false
  if [[ "-f" == $1 ]]; then
    file_only=true
    shift
  fi

  local -a cmd=($(echo $1))
  [[ -z $cmd ]] && {
    echo "No command given"
    return 1
  }
  shift

  local -a args
  if [[ -z "$1" || "${@: -1}" == -* ]]; then
    args=($@)
    query=
  else
    args=(${@:1:$# -1})
    query="${@: -1}"
  fi

  local picked
  picked=$(_pick $file_only "$query") || return $?
  "${cmd[@]}" "${args[@]}" "$picked"
}

function e() {
  _pick_and_execute -f less "$@"
}

function n() {
  _pick_and_execute -f nano "$@"
}

function sn() {
  _pick_and_execute -f "sudo nano" "$@"
}

function m() {
  _pick_and_execute mate "$@"
}

function sm() {
  _pick_and_execute "sudo mate" "$@"
}

function o() {
  _pick_and_execute open "$@"
}

function cdf() {
  local picked__dir=$(fd -t d | grep -v '\.git/' | fzf --query="$1") || return $?
  cd "$picked__dir"
}

#############################
### pass
#############################
alias pe="pass edit"

function pm() {
  [[ -z "$*" ]] && echo "Please give a pass-name for grabbing e-mail address." && return 1;
  local p_res
  p_res=$(pass "$*") || return $?

  local res=$(echo "$p_res" | grep --binary-files=text -m 1 -e "^m: ")
  [[ -z $res ]] && echo "No mail address found for: $*" && return 1
  res=$(echo "$res" | cut -c 4-)

  if [[ ! -t 1 ]]; then
    echo "$res"
  else
    printf "%s" "$res" | pbcopy
    echo "$res (copied to clipboard)"
  fi
}

function pu() {
  [[ -z "$*" ]] && echo "Please give a pass-name for grabbing username." && return 1;
  local p_res
  p_res=$(pass "$*") || return $?

  local res=$(echo "$p_res" | grep --binary-files=text -m 1 "^u: ")
  if [[ -z $res ]]; then
    res=$(echo "$p_res" | grep --binary-files=text -m 1 "^CID: ")
    if [[ -z $res ]]; then
      echo "No username found for: $*" && return 1
    else
      res=$(echo "$res" | cut -c 6-)
    fi
  else
    res=$(echo "$res" | cut -c 4-)
  fi

  if [[ ! -t 1 ]]; then
    echo "$res"
  else
    printf "%s" "$res" | pbcopy
    echo "$res (copied to clipboard)"
  fi
}

function po() {
  [[ -z "$*" ]] && echo "Please give a pass-name for grabbing online login site." && return 1;
  local p_res
  p_res=$(pass "$*") || return $?

  local res=$(echo "$p_res" | grep --binary-files=text -m 1 -e "^o: ")
  [[ -z $res ]] && echo "No online link found for: $*" && return 1
  res=$(echo "$res" | cut -c 4-)

  if which f >/dev/null; then
    f "$res"
  else
    open "$res"
  fi
}

#############################
### misc stuff
#############################
alias showUnixTime="/usr/local/bin/bash -c 'while true; do printf \"\\r\\e[K\$EPOCHREALTIME\"; done'"
alias weekday="case $(date +%u) in; 1) echo Monday;; 2) echo Tuesday;; 3) echo Wednesday;; 4) echo Thursday;; 5) echo Friday;; 6) echo Saturday;; 7) echo Sunday;; *) echo \"Invalid week day number: $(date +%u)\";; esac"
alias lsusers="dscl . list /Users | grep -v ^_"

function backup() {
  local target=$(git config --global custom.backup)
  if [[ -z $target ]]; then
    echo "Please set target first."
    return 1;
  fi
  local drive=$(echo "$target" | sed 's/^\/Volumes\///;s/\/.*$//')
  echo "Plug in $drive now"
  while [[ -z $(ls /Volumes | grep "$drive") ]]; do
    sleep 1
  done
  echo "Detected $drive!"
  while [[ ! -w "$target" ]]; do
    sleep 1 # wait for mounting
  done
  echo "Starting backup script now."
  echo
  "$P"/backup -t "$target" && unmount
}

function pdfpages() {
  local -a files=("$@")
  if [[ -z "$*" ]]; then
    IFS=$'\n' files=($(fd --no-ignore-vcs -t f -d 1 '\.pdf')); unset IFS
    [[ -z "$files" ]] && echo "No .pdf file found." && return 0
  fi
  local -i pages=$(echo $(mdls -name kMDItemNumberOfPages "${files[@]}" | sed "s/kMDItemNumberOfPages =/+/g") | cut -c "3-" | bc)
  printf "%d pages found in %d files.\n" "$pages" "${#files}"
}

function pdfgrepc() {
  [[ -z "$1" ]] && return 1
  pdfgrep -c "$@" * | grep -v ':0' | tr ':' ' ' | awk '{print $2"\t"$1}' | sort -n
}

function zombiesAndStuff() {
  ps aux | awk ' $8 !~ /S/ {print $0}' | grep -v "ps aux"
}

function showHexFlow() {
  _pick_and_execute -f hexdump "$@" | sed 's/[0123456789abcdef]\{7\}//g' | grep --color=always -e "3e\|$" | xargs printf "%s "; echo
}

function battery() {
  system_profiler SPPowerDataType | grep "Charge [^I]" | awk '{print $NF}' | tr '\n' ' ' | awk '{ print $1 / $2 * 100 "%"}'
}

function ocr() {
  local imagefile="${@: -1}"
  if ! hash convert &>/dev/null; then
    echo "Please make sure that convert (see imagemagick) is in your path!"
    return 1
  elif ! hash tesseract &>/dev/null; then
    echo "Please make sure that tesseract is in your path!"
    return 1
  elif [[ -f "$imagefile" ]]; then
    shift -p
    local res=$(convert "$imagefile" -colorspace Gray -depth 8 -resample 200x200 -flatten -alpha Off - | tesseract "$@" - -)
    if ! echo "$res" | grep "\w" &>/dev/null; then
      echo "Oh dear, no results! :(" >&2
      echo "Maybe you should try: $0 --psm 11 $imagefile" >&2
      echo "See tesseract --help-extra for more help." >&2
      return 2
    else
      echo "$res"
    fi
  else
    echo "Usage: $(basename $0) [\e[4mtesseract options\e[0m \e[4m...\e[0m] imagefile" >&2
    echo "Print result of optical character recognition with tesseract to stdout." >&2
    echo "See tesseract --help-extra for more help." >&2
  fi
}

function secinmp4() {
  fd -0 mp4 | xargs -L 1 -0 ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 | sed 's/^/+/' | tr -d '\n' | cut -c 2- | bc
}
