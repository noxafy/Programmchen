#!/bin/bash

header='Accept-Language: de,en-US;q=0.7,en;q=0.3'
CURL="curl -s -A 'Mozilla/5.0'";
sites="songtexte.com songlyrics.com musixmatch.com azlyrics.com genius.com plyrics.com"
#Search with ecosia for (compatibility with special characters and) easier grep
GOOG_URL='https://www.ecosia.org/search'
ARTIST=
TITLE=
VERBOSE=
QUIET=
AUTOSELECT=true
help="$(basename $0) - Find out the song lyrics for a currently playing song.

This script is capable of finding out the Artist and Title of the currently
playing song. If, you are using Rhythmbox or Spotify. See usage message below.

Do it like this:
  $(basename $0) <title> <artist>       - To look up lyrics for a song (you can omit artist if unknown)
  $(basename $0) spotify                - To look up info for the currently playing song in Spotify
  $(basename $0) rhythmbox|rbox         - To look up info for the currently playing song in Rhythmbox
Also, you can give an url for extracting directly: 
  $(basename $0) <songtexte.com url>    - To display the lyrics from a given songtexte.com url
  $(basename $0) <songlyrics.com url>   - To display the lyrics from a given songlyrics.com url
  $(basename $0) <genius.com url>       - To display the lyrics from a given genius.com url
  $(basename $0) <musixmatch.com url>   - To display the lyrics from a given musixmatch.com url
  $(basename $0) <azlyrics.com url>     - To display the lyrics from a given azlyrics.com url
  $(basename $0) <plyrics.com url>      - To display the lyrics from a given plyrics.com url

Dependency to \"recode\". Parameter -v produces debugging output, --ask disables autoselection, -q suppresses most messages.
"
# prevent sed error on bad encoded characters by reading as ascii (test for failing (greek text): https://www.musixmatch.com/lyrics/Vangelis-Kakouriotis/Na-M-Agapas)
LC_CTYPE=C
LANG=C

#TODO: html encode for musixmatch -> title and artist matching individually for each site

#adding new lyrics sites:
#  add new site hostname to $sites
#  find xml-elements directly before and after the text
#  add ${site%.*} function name with a awk matching pattern
#  add filter for lyrics-sites to google function if applicable
#  add filter for site-specific non-lyrics line-contents (awk grep only whole lines, so every outside of diamons is shown)
#  add site to usage message

# This is used to get the url for the lyrics
function google {
  if [[ -n $VERBOSE ]]; then
    #add v for more information about headers
    stream=$($CURL -GLm 10 -H "$header" ${GOOG_URL} --data-urlencode "q=$*")
    if [[ ${#stream} -lt 2000 ]]; then
      echo "Answer may indicate failing:" >&2
      printf "%s" "$stream" | xargs -L 1 printf "\t%s" >&2
    fi
  else
    stream=$($CURL -GLm 10 -H "$header" ${GOOG_URL} --data-urlencode "q=$*")
  fi
  #echo "link: ${GOOG_URL}?q=$*" >&2
  res=$(echo "$stream" | grep -o "result-url\" href=\"[^\"]*" | sed 's/result-url" href="//')
  if [[ -n $(echo "$res" | grep "songtexte\.com") ]]; then
    res=$(echo "$res" | grep "/songtext/")
  elif [[ -n $(echo "$res" | grep "azlyrics\.com") ]]; then
    res=$(echo "$res" | grep "/lyrics/")
  elif [[ -n $(echo "$res" | grep "songlyrics\.com") ]]; then
    res=$(echo "$res" | grep -- "-lyrics/")
  elif [[ -n $(echo "$res" | grep "genius\.com") ]]; then
    res=$(echo "$res" | grep -- "-lyrics")
  elif [[ -n $(echo "$res" | grep "musixmatch\.com") ]]; then
    res=$(echo "$res" | grep "/lyrics/")
  fi
  echo "$res"
}

# get resulting text from website
function fetchResult() {
  [[ -z "$QUIET" ]] && echo "open $1" >&2
  
  #test if url exists, print http state
  if [[ -n $VERBOSE ]]; then
    echo "
Fetching header: $CURL -H \"$header\" -SI \"$1\"" >&2
  fi
  testUrl=$($CURL -H "$header" -SI "$1" 2>&1)
  state=$(echo "$testUrl" | sed -n 1p)
  if [[ $state != *200* ]]; then
    echo "Error in fetching site: $state" >&2
    if [[ ! -t 0 ]]; then
      exit 1
    fi
    res=$($CURL -H "$header" "$1");
    printf "Do you want to see details? (${#testUrl}/${#res}) (y/n) [n]: "
    read ans
    case $ans in
    y)
      echo "Command: $CURL -H \"$header\" \"$1\""
      echo "Command: $CURL -H \"$header\" \"$1\"
      
      Answer-Header (${#testUrl}):
      $testUrl
      
      Answer (${#res}):
      $res" | less
      ;;
    esac
    return
  fi
  if [[ -n $VERBOSE ]]; then
    echo "******Answer-Header (START)******" >&2
    printf "%s" "$testUrl" >&2
    echo "******Answer-Header (END)*********
" >&2
  else
    [[ -z "$QUIET" ]] && echo "$state" >&2
  fi

  #awk lyrics from site
  if [[ -n $VERBOSE ]]; then
    echo "Fetching lyrics: $CURL -H \"$header\" \"$1\"" >&2
  fi
  res=$($CURL -H "$header" "$1" | awk "$2");
  if [[ -n $VERBOSE ]]; then
    if [[ -n $res ]]; then
      echo "Lyrics in site found! (lenght: ${#res})" >&2
    else
      echo "Extracting lyrics failed on awk (or curl))!" >&2
      return;
    fi
  fi
  
  #reove site-specific non-lyrics line-contents
  if [[ -n $(echo "$1" | grep "musixmatch\.com") ]]; then
    res=$(echo "$res" | sed 's/.*<p class="mxm-lyrics__content ">//'| sed 's/<\/p>.*//')
  fi
  
  #further beautifying
  res=$(echo "$res" | node -e 'process.stdin.resume(); process.stdin.setEncoding("utf8");
       var content = "";

       process.stdin.on("data", function(chunk) {
           content+=chunk
       });

       process.stdin.on("end", function() {
         var result="";
         var nextchar = "";
         var skip = false;

         for (i = 0; i <= content.length; i++) {
           nextchar = content.charAt(i);
           // console.error(i + ": " + nextchar)

           if (skip) {
             if (nextchar == ">"){
               skip = false;
             }
           } else {
             switch (nextchar) {
               case "<":
                 skip = true;
                 break;
               default:
                 result+=nextchar;
             }
           }
         }
         console.log(result)
       });' \
      | perl -pe 's/^[ \t]+//' \
      | recode html..latin1 \
      | grep -v "Zur deutschen Übersetzung" \
      | grep -v "Noch keine Übersetzung vorhanden." \
      | grep -v "Jetzt Übersetzung hinzufügen" \
      | grep -v "Leider kein Songtext vorhanden." \
      | grep -v "Jetzt Songtext hinzufügen" \
      | grep -v "Laden des Songtextes wird vorbereitet ..." \
      | sed 's/^ *//g' \
      | sed '/^$/N;/^\n$/D');
#      | sed 's/’//g' \
#      | sed 's/‘//g' \
#      | sed 's/”/"/g' \
#      | sed 's/“/"/g' \
#      | sed 's/…/.../g' \
#      | sed 's/[fF][uU][cC][kK]/[32mF***[39m/g' \
#      | sed 's/[sS][hH][iI][tT]/[32mS***[39m/g' \
  
  if [[ -z $res ]]; then
    echo "There might be missing some lyrics..." >&2
  fi
}

function songtexte() {
  fetchResult "$1" '/<div id=\"lyrics\">/, /<div class=\"mobileShare\">/'
}

function songlyrics() {
  fetchResult "$1" '/<p id=\"songLyricsDiv\"/, /<\/p>/'
}

function musixmatch() {
  fetchResult "$1" '/<p class=\"mxm-lyrics__content \">/, /<\/p>/'
}

function azlyrics() {
  fetchResult "$1" '/<!-- Usage of azlyrics.com content by any third-party lyrics provider is prohibited by our licensing agreement. Sorry about that. -->/, /<\/div>/'
}

function genius() {
  fetchResult "$1" '/<div class=\"lyrics\">/, /<\/div>/'
}

function plyrics() {
  fetchResult "$1" '/start of lyric/, /end of lyric/'
}

function finishIt() {
  if [[ -n "$ARTIST" && -n "$TITLE" ]]; then
    if [[ -t 1 ]]; then
      printf "\n\e[1;4m%s - %s\e[0m\n" "$ARTIST" "$TITLE"
    else
      printf "%s - %s\n" "$ARTIST" "$TITLE"
      [[ -z "$QUIET" ]] && echo "Songtext piped (length: ${#res})." >&2
    fi
  fi
  #guarantee one newline before...
  if [[ ! "$res" =~ ^[[:space:]] ]]; then
    echo
  fi
  echo "$res"
  #... and one newline after
  if [[ ! "$res" =~ [[:space:]]$ ]]; then
    echo
  fi
  exit 0
}

function tryURL() {
  if [[ "$1" == "urlonly" ]]; then
    local urlonly=1
    shift
  fi
  for site in $sites; do
    if [[ "$(echo $1 | grep -i "https\?://.*$site")" ]]; then
      ${site%.*} "$1"
      if [[ -n $urlonly ]]; then
        if [[ -n $res ]]; then
          finishIt
        else
          echo "Sorry, couldn't extract lyrics from that URL..." >&2
          exit 1
        fi
      fi
    fi
  done
  
  if [[ -n $urlonly && "$1" =~ '^https?://(www\.)?[A-Za-z0-9-]*\.[A-Za-z0-9\\+&@./#%=~_|-]*$' ]]; then
    echo "Sorry, that site is not supported. Maybe you can add it. See in docs."
    exit 1
  fi
}

function postformat() {
  cat | iconv -c -f utf-8 -t ascii//translit | sed "s/[\"^'\`~]//g"
}

function withHyphen0() {
  echo "$*" | sed 's/ /-/g' | sed 's/[+*,/\?\$]//g' | sed 's/-\{2,\}/-/g'
}

function withHyphen() {
  withHyphen0 $(echo "$*" | sed "s/'/-/g" | sed "s/&//g") | postformat
}

function withHyphen2() {
  withH=$(withHyphen0 $(echo "$*" | sed "s/'/-/g" | sed "s/&//g"))
  perl -MURI::Escape -e 'print uri_escape($ARGV[0]);' "$withH"
}

function withHyphen3() {
  withHyphen0 $(echo "$*" | sed "s/'//g" | sed "s/&/and/g") | postformat
}

function noSpaces() {
  echo "$*" | sed 's/[+*,/\?\$& ]//g' | sed "s/'//g" | postformat
}

function preformat() {
  echo "$*" | sed 's/(.*)//g' | sed 's/\[.*\]//g' | sed 's/ - .*//g' | sed 's/\.\{1,\}/-/g' | sed 's/ \{1,\}/ /g' | sed 's/-*//'
}

function findLyrics() {
  [[ -z "$QUIET" ]] && echo "Artist: $ARTIST
Title: $TITLE
" >&2
  
  tileInUrl=$(preformat $TITLE | sed 's/ - [Ll]ive.*//g')
  titleWithHyphen=$(withHyphen $tileInUrl)
  titleWithHyphen2=$(withHyphen2 $tileInUrl)
  titleWithHyphen3=$(withHyphen3 $tileInUrl)
  titleNoSpaces=$(noSpaces $tileInUrl)

  artistInUrl=$(preformat $ARTIST)
  artistWithHyphen=$(withHyphen $artistInUrl)
  artistWithHyphen2=$(withHyphen2 $artistInUrl)
  artistWithHyphen3=$(withHyphen3 $artistInUrl)
  artistNoSpaces=$(noSpaces $artistInUrl)
  
  if [[ -n $VERBOSE ]]; then
    echo "******Debug matching title and artist******
titleInUrl: $tileInUrl
titleWithHyphen: $titleWithHyphen
titleWithHyphen2: $titleWithHyphen2
titleWithHyphen3: $titleWithHyphen3
titleNoSpaces: $titleNoSpaces

artistInUrl: $artistInUrl
artistWithHyphen: $artistWithHyphen
artistWithHyphen2: $artistWithHyphen2
artistWithHyphen3: $artistWithHyphen3
artistNoSpaces: $artistNoSpaces
********************************************" >&2
  fi
  
  # Tell if artist conversion failed
  if [[ -n "$ARTIST" && -z "$artistWithHyphen" && -z "$artistWithHyphen2" && -z "$artistNoSpaces" ]]; then
    echo "Couldn't convert artist name to ascii. Please give it in latin characters." >&2
  fi
  
  # Title must not be empty
  if [[ -z "$titleWithHyphen" && -z "$titleWithHyphen2" && -z "$titleWithHyphen3" && -z "$titleNoSpaces" ]]; then
    echo "Couldn't convert title to ascii. Please give it in latin characters. It must not be empty, so exiting now." >&2
    exit 1
  fi
  
  OVERALL=()
  for site in $sites; do
    printf "Looking for lyrics at %s: " "$site" >&2
    if [[ -n $VERBOSE ]]; then
      [[ -z "$QUIET" ]] && echo >&2
    fi
    ALL=($(google "$ARTIST $TITLE lyrics site:$site"));
    #skip if no results found
    if [[ -z ${ALL[@]} ]]; then
      echo "No results. Lets try another..." >&2
      continue;
    fi
    
    if [[ -n "$AUTOSELECT" || ! -t 0 ]]; then
      # try to validate self
      # only title is required (grep would pass everything trough if both empty)
      for i in "${ALL[@]}"; do
        if [[ ( -n "$titleWithHyphen" && -n $(echo "$i" | grep -i -e "$titleWithHyphen" | grep -i -e "$artistWithHyphen") )
          || ( -n "$titleNoSpaces" && -n $(echo "$i" | grep -i -e "$titleNoSpaces" | grep -i -e "$artistNoSpaces") )
          || ( -n "$titleWithHyphen2" && -n $(echo "$i" | grep -i -e "$titleWithHyphen2" | grep -i -e "$artistWithHyphen2") )
          || ( -n "$titleWithHyphen3" && -n $(echo "$i" | grep -i -e "$titleWithHyphen3" | grep -i -e "$artistWithHyphen3") ) ]]; then
          echo "Lyrics found!" >&2

          ${site%.*} $i

          if [[ -n $res ]]; then
            finishIt
          else
            echo "Well, that URL sucked. Lets try another..." >&2
          fi
        elif [[ -n $VERBOSE ]]; then
          echo "URL not matching: $i" >&2
        fi
      done
      echo "No matching site found. Lets try another site..." >&2
      
      #add ALL to OVERALL and try to find in next site
      OVERALL+=("${ALL[@]}")
    else
      echo "${#ALL[@]} results found."
      while [[ -n "${ALL[@]}" ]]; do
        j=1
        for resURL in ${ALL[@]}; do
          if [[ ( -n "$titleWithHyphen" && -n $(echo "$resURL" | grep -i -e "$titleWithHyphen" | grep -i -e "$artistWithHyphen") )
            || ( -n "$titleNoSpaces" && -n $(echo "$resURL" | grep -i -e "$titleNoSpaces" | grep -i -e "$artistNoSpaces") )
            || ( -n "$titleWithHyphen2" && -n $(echo "$resURL" | grep -i -e "$titleWithHyphen2" | grep -i -e "$artistWithHyphen2") )
            || ( -n "$titleWithHyphen3" && -n $(echo "$resURL" | grep -i -e "$titleWithHyphen3" | grep -i -e "$artistWithHyphen3") ) ]]; then
            echo "$j: $resURL (!)" >&2
          else
            echo "$j: $resURL" >&2
          fi
          ((j++))
        done
        printf "Is there anyone right? (1-${#ALL[@]} / c (continue) / q (= quit)) [c]: " >&2
        read ans
        if [[ $ans =~ ^[0-9]+$ ]]; then
          if [[ $ans -le ${#ALL[@]} ]]; then
            ((ans--))
            tryURL "${ALL[$ans]}"

            if [[ -n $res ]]; then
              finishIt
            else
              echo "Well, that URL sucked. Lets try another..." >&2
              echo "DEBUG: $res" >&2
              #remove that URL from OVERALL
              ALL=("${ALL[@]:0:$ans}" "${ALL[@]:((ans+1))}")
            fi
          else
            echo "That number was too high..." >&2
            exit 1;
          fi
        elif [[ -z "$ans" || "$ans" == c ]]; then
          continue 2;
        else
          # q or any other not c and non-integer
          exit 0;
        fi
      done
    fi
  done
  
  if [[ -n "$AUTOSELECT" ]]; then
    printf "No matching site found in all sites. " >&2
  fi
  
  # implicit if autoselect==true
  if [[ -t 0 && -n ${OVERALL[@]} ]]; then
    echo "Anyway, some sites where found:" >&2
    while [[ -n "${OVERALL[@]}" ]]; do
      j=1
      for resURL in ${OVERALL[@]}; do
        echo "$j: $resURL" >&2
        ((j++))
      done
      printf "Is there anyone right? (1-${#OVERALL[@]} / q (= quit)) [q]: " >&2
      read ans
      if [[ $ans =~ ^[0-9]+$ ]]; then
        if [[ $ans -le ${#OVERALL[@]} ]]; then
          ((ans--))
          tryURL "${OVERALL[$ans]}"

          if [[ -n $res ]]; then
            finishIt
          else
            echo "Well, that URL sucked. Lets try another..." >&2
            #remove that URL from OVERALL
            OVERALL=("${OVERALL[@]:0:$ans}" "${OVERALL[@]:((ans+1))}")
          fi
        else
          echo "That number was too high..." >&2
          exit 1;
        fi
      elif [[ -z $ans ]]; then
        break;
      else
        # q or any other non-integer
        exit 0;
      fi
    done
  fi
  
  [[ -z "$QUIET" ]] && echo "Ooops, no site left. " >&2
  
  #if [[ -e /usr/local/opt/bash-snippets/bin/lyrics && -n "$ARTIST" ]]; then
  #  echo "Last chance: lyrics from bash-snippets" >&2
  #  /usr/local/opt/bash-snippets/bin/lyrics -a "$ARTIST" -s "$TITLE" && exit 0
  #fi
  echo "Givin' up now :(" >&2
  
  #Get searching site for copy & paste
  #Replace &, " and space
  if [[ -n "$ARTIST" ]]; then
    Q="$ARTIST $TITLE lyrics"
  else
    Q="$TITLE lyrics"
  fi
  Q=${Q//&/%26}
  Q=${Q//\"/%22}
  Q=${Q//\ /+}
  echo "${GOOG_URL}?q=$Q" >&2
}

################################################################################
# Look up the title and artist in spotify
################################################################################
function lookupSpotifyInfo() {
  [[ -z "$QUIET" ]] && echo "Looking up lyrics by Spotify artist and title..." >&2
  # Checks $OSTYPE to determine the proper command for artist/title query
  if [[ "$OSTYPE" == "linux-gnu" ]]; then
    ARTIST="$(dbus-send --print-reply --session --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 \
      org.freedesktop.DBus.Properties.Get string:'org.mpris.MediaPlayer2.Player' string:'Metadata' \
        | grep -A 3 artist | grep string | grep -v xesam | sed 's/^\s*//' | cut -d ' ' -f 2- \
          | tr '(' ' ' | tr ')' ' ' | tr '"' ' ' )";
    TITLE="$(dbus-send --print-reply --session --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 \
      org.freedesktop.DBus.Properties.Get string:'org.mpris.MediaPlayer2.Player' string:'Metadata' \
        | grep -A 3 title | grep string | grep -v xesam | sed 's/^\s*//' | sed 's/^variant\s*//' \
          | cut -d ' ' -f 2- | tr '(' ' ' | tr ')' ' ' | tr '"' ' ' )";
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    #precautionally open it
    if [[ $(ps -x | grep 'Spotify.app' | wc -l) -eq 1 ]]; then
      echo "Opening Spotify at first ..." >&2
      open -j /Applications/Spotify.app/ && sleep 3
    fi
    ARTIST="$(osascript -e 'tell application "Spotify" to artist of current track as string')";
    TITLE="$(osascript -e 'tell application "Spotify" to name of current track as string')";
  else
    echo "Your OS doesn't appear to be supported" >&2
  fi

  if [[ -z "$ARTIST" || -z "$TITLE" ]]; then
    echo "There was a problem getting the currently playing info from spotify" >&2
    exit 1;
  fi
}

################################################################################
# Look up the song info for the currently playing song in Rhythmbox
################################################################################
function lookupRhythmboxInfo() {
  [[ -z "$QUIET" ]] && echo "Looking up title by Rhythmbox artist and title..." >&2
  ARTIST="$(rhythmbox-client --print-playing-format %ta)";
  TITLE="$(rhythmbox-client --print-playing-format %tt)";   
}

################################################################################
# Main (Arg parsing crap)
################################################################################

while [[ -n $1 ]]; do
  case $1 in
    rhythmbox|rbox)
      lookupRhythmboxInfo
      break;
      ;;
    spotify)
      lookupSpotifyInfo
      break;
      ;;
    -h|--help)
      printf "%s" "$help"
      exit 0
      ;;
    -v)
      VERBOSE=true
      shift
      ;;
    -q)
      QUIET=true;
      shift
      ;;
    --ask)
      AUTOSELECT=""
      shift
      ;;
    -*)
      printf "Unknown Argument: %s\nSee -h for more help.\n" "$1"
      exit 1
     ;;
    *)
      waitnet -s >&2
      # If given an url, just browse it
      tryURL "urlonly" "$1"

      if [[ -n "$1" ]]; then
        TITLE=$1
        ARTIST=$2
      else
        lookupSpotifyInfo
        #echo "Please give a Title and an artist or spotify or rhythmbox as arguments. See -h for more information." 
        #exit 1
      fi
      findLyrics
      exit 0
      ;;
  esac
done

waitnet -s >&2
findLyrics
