#!/bin/bash

removed=0 #counter for removed things
verbose=1 #0=be silent, 1=only say when sth has been removed, 2=verbose everything
rec="active" #by default clean will clean recursively
cleanedUp=0 #storage freed in bytes
path="." #path as root for cleaning
uselocate=0
usage="Usage: \e[1m$(basename $0)\e[0m -h | [-s|-v] [-l | [-t] [\e[4mpath\e[0m]]"
help="Cleans up the current (or given) directory recursively from .DS_Store.
$usage
	\e[1m-h\e[0m	Displays this message and exits.
	\e[1m-s\e[0m	Silence. Show errors only.
	\e[1m-v\e[0m	Verbose everything.
	\e[1m-l\e[0m	Using locate instead of find. Deleting from all indexed dirs.
		Overwrites \e[1m-t\e[0m.
	\e[1m-t\e[0m	Clean only the current (or given) dir, do not search recursively.
	\e[4mpath\e[0m	Cleans up a given path instead of current.
"

while [[ -n "$*" ]]; do
  case "$1" in
    -v)
      verbose=2
      ;;
    -t|this)
      rec=
      ;;
    -s)
      verbose=0
      ;;
    -l)
      uselocate=1
      ;;
    -h|"-?")
      printf "$help"
      exit 0
      ;;
    -*)
      printf "Wrong argument: %s\n$usage -- See -h for more help.\n" "$1"
      exit 1
      ;;
    *)
      if [[ -e $1 && -d $1 ]]; then
          path="$1"
        else
          echo "$1 is not a directory. See -h for more help."
          exit 1
      fi
      ;;
  esac
  shift
done

trap 'resumee; exit 0' 2

sizeFormat() {
  if [[ $1 -ge 100000000000 ]]; then
    printf "%.0f GB" $(echo "scale=1; $1/1000000000" | bc)
  elif [[ $1 -ge 10000000000 ]]; then
    printf "%.1f GB" $(echo "scale=2; $1/1000000000" | bc)
  elif [[ $1 -ge 1000000000 ]]; then
    printf "%.2f GB" $(echo "scale=3; $1/1000000000" | bc)
  elif [[ $1 -ge 100000000 ]]; then
    printf "%.0f MB" $(echo "scale=1; $1/1000000" | bc)
  elif [[ $1 -ge 10000000 ]]; then
    printf "%.1f MB" $(echo "scale=2; $1/1000000" | bc)
  elif [[ $1 -ge 1000000 ]]; then
    printf "%.2f MB" $(echo "scale=3; $1/1000000" | bc)
  elif [[ $1 -ge 100000 ]]; then
    printf "%.0f kB" $(echo "scale=1; $1/1000" | bc)
  elif [[ $1 -ge 10000 ]]; then
    printf "%.1f kB" $(echo "scale=2; $1/1000" | bc)
  elif [[ $1 -ge 1000 ]]; then
    printf "%.2f kB" $(echo "scale=3; $1/1000" | bc)
  else
    printf "$1 Bytes"
  fi
}

clean() {
  storage=$(stat -f %Z $1)
  ausg=$(rm -f $1)
  if [[ $? -ne 0 ]]; then
    if [[ $verbose -ge 1 && -n $ausg ]]; then
      echo $ausg
    fi
  else
    if [[ $verbose -ge 1 ]]; then
      printf "$1 removed (%s)\n" "$(sizeFormat $storage)"
    fi
    cleanedUp=$((cleanedUp + storage))
    ((removed++))
  fi
}

resumee() {
if [[ $verbose -gt 0 ]]; then
  if [ $removed == 0 ]; then
    printf "No file "
  elif [[ $removed -eq 1 ]]; then
    printf "1 file "
  else
    printf "$removed files "
  fi
  printf "removed"

  if [[ $removed -gt 0 ]]; then
    printf ". Approximately %s of storage freed" "$(sizeFormat $cleanedUp)"
    if [[ $cleanedUp -gt 1000 ]]; then
      printf " ($cleanedUp Bytes)"
    fi
  fi
  printf "."
  echo
fi
}

IFS=$'\n'; set -f;
if [[ $uselocate != 0 ]]; then
  findres="$(locate .DS_Store)"
  for file in $findres; do
    if [[ -w $file ]]; then
      clean "$file"
    fi
  done
else
  if [[ -n $rec ]]; then
    findres="$(find $path -name .DS_Store)"
  else
    findres="$(find $path -maxdepth 1 -name .DS_Store)"
  fi
  for file in $findres; do
    clean "$file"
  done
fi

resumee
